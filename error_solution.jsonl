{"error": "TypeError: 'NoneType' object is not iterable in Python", "solution": "<p>It means the value of <code>data</code> is <code>None</code>.</p>\n"}
{"error": "TypeError: 'NoneType' object is not iterable", "solution": "<p>You try to unpack the return value of displayCost into 4 variables, but displayCost doesn't return anything.  Because every function call returns something in Python (or throws an exception), None is returned.  Then None can't be unpacked.</p>\n\n<p>You probably want to change:</p>\n\n<pre><code>companyName, monthAverage, costPerTon, totalCost = displayCost(companyName, monthAverage, costPerTon, totalCost)\n</code></pre>\n\n<p>To:</p>\n\n<pre><code>displayCost(companyName, monthAverage, costPerTon, totalCost)\n</code></pre>\n"}
{"error": "TypeError: NoneType object is not iterable", "solution": "<p>Your function <code>wenjian()</code> does not have any <code>return</code> statements, so it will always return <code>None</code>, by default. That's why <code>Names = wenjian(file)</code> assigns the value <code>None</code> to <code>Names</code>, and so you can't iterate over <code>Names</code> with the for loop.</p>\n"}
{"error": "**TypeError: 'NoneType' object is not iterable**", "solution": "<p>You have a typo in your <code>df = run_query(...)</code> line.</p>\n<p>You used a comma; but you should use a %.</p>\n<p>i.e.</p>\n<pre><code>\ndf = run_query(\"INSERT INTO `ML1`(`day_of_test`, `gold_close`, `sap_close`, `bonds_close`, `btc_est`, `btc_actual`,`actual_difference`) VALUES (%s, %s, %s, %s, %s, %s, %s);\" %\n        (day_of_test, gold_close, sap_close, bonds_close, btc_est, btc_actual, actual_difference))\n\n</code></pre>\n"}
{"error": "TypeError: 'NoneType' object is not iterable :(", "solution": "<pre><code>def powerset(nums):\n    list_1=[]\n    recursion(0,nums,list_1)\n    print (list_1)\n\ndef recursion(start,nums,list_):\n    if start>len(nums)-1:\n        list_.append([])\n        return 0\n    recursion(start+1,nums,list_)\n    i=0\n    save_list=list_\n    save_len=len(list_)\n    while i<save_len:\n        listy=save_list[i]\n        listy.append(nums[start])\n        list_[i].extend(listy)\n        i += 1\n</code></pre>\n\n<p>Try this. Your problem was with append as chepner said.</p>\n"}
{"error": "TypeError: 'NoneType' object is not iterable in Python", "solution": "<p>It means the value of <code>data</code> is <code>None</code>.</p>\n"}
{"error": "TypeError: 'NoneType' object is not iterable", "solution": "<p>You try to unpack the return value of displayCost into 4 variables, but displayCost doesn't return anything.  Because every function call returns something in Python (or throws an exception), None is returned.  Then None can't be unpacked.</p>\n\n<p>You probably want to change:</p>\n\n<pre><code>companyName, monthAverage, costPerTon, totalCost = displayCost(companyName, monthAverage, costPerTon, totalCost)\n</code></pre>\n\n<p>To:</p>\n\n<pre><code>displayCost(companyName, monthAverage, costPerTon, totalCost)\n</code></pre>\n"}
{"error": "TypeError: NoneType object is not iterable", "solution": "<p>Your function <code>wenjian()</code> does not have any <code>return</code> statements, so it will always return <code>None</code>, by default. That's why <code>Names = wenjian(file)</code> assigns the value <code>None</code> to <code>Names</code>, and so you can't iterate over <code>Names</code> with the for loop.</p>\n"}
{"error": "**TypeError: 'NoneType' object is not iterable**", "solution": "<p>You have a typo in your <code>df = run_query(...)</code> line.</p>\n<p>You used a comma; but you should use a %.</p>\n<p>i.e.</p>\n<pre><code>\ndf = run_query(\"INSERT INTO `ML1`(`day_of_test`, `gold_close`, `sap_close`, `bonds_close`, `btc_est`, `btc_actual`,`actual_difference`) VALUES (%s, %s, %s, %s, %s, %s, %s);\" %\n        (day_of_test, gold_close, sap_close, bonds_close, btc_est, btc_actual, actual_difference))\n\n</code></pre>\n"}
{"error": "TypeError: 'NoneType' object is not iterable :(", "solution": "<pre><code>def powerset(nums):\n    list_1=[]\n    recursion(0,nums,list_1)\n    print (list_1)\n\ndef recursion(start,nums,list_):\n    if start>len(nums)-1:\n        list_.append([])\n        return 0\n    recursion(start+1,nums,list_)\n    i=0\n    save_list=list_\n    save_len=len(list_)\n    while i<save_len:\n        listy=save_list[i]\n        listy.append(nums[start])\n        list_[i].extend(listy)\n        i += 1\n</code></pre>\n\n<p>Try this. Your problem was with append as chepner said.</p>\n"}
